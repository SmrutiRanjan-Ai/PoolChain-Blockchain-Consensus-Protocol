from node import *


class StubbornNode(Node):
    def __init__(self, creation_time, node_id, bandwidth):
        super().__init__(creation_time, node_id, bandwidth)
        self.hash_power = 'high'
        self.bandwidth = 'FAST'
        self.hash_mean = g.adversary_mining_power
        self.completed_trans = set()
        self.block_qty = 0
        self.type = 'selfish'

    def create_blockchain(self, genesis):
        '''Initialize Blockchain'''
        self.blockchain = Blockchain(genesis)
        self.on_init(0)

    def check_mempool(self, timestamp):
        ''' Check mempool to add into block and trigger mining of block'''
        if not self.busy:
            if timestamp > 0.95 * g.final_timestamp:
                self.mempool_limit = g.TXN_NUM / 100
            if timestamp > 0.98 * g.final_timestamp:
                self.mempool_limit = 0
            if len(self.mempool) > self.mempool_limit:
                self.create_block(timestamp, self.chain)

    def on_init(self, timestamp):
        public_chain = self.blockchain.tree.longest_chain()
        self.chain = public_chain
        self.pending_block=None
        self.busy=False
        if g.mining_log:
            print(timestamp, "I am Initiated")

    def receive_message(self, timestamp, message, sender):
        if message.type == 'txn':
            if message.content not in self.mempool:
                self.mempool.add(message.content)
            self.broadcast_message(timestamp, message, sender)
            if g.message_log: print(timestamp, self, " Received Transaction", message.content, "from ", sender.id)
        if message.type == 'blk':
            if message.content not in self.received_blk:
                if g.message_blk_log: print(timestamp, self, " Received Block", message.content, "from ", sender.id)
                self.received_blk.add(message.content)
                self.receive_blk(timestamp, message.content, sender)
                ''' Selfish Miners does not forward block generated by other nodes'''

    def receive_blk(self, timestamp, block, sender):
        print(timestamp, "99 recive blk", block, block.header['prev_hash'])
        self.check_stubborn(timestamp, block, sender)

    def check_stubborn(self, timestamp, block, sender):
        '''Check Lead and take action on received blk from honest miners'''
        public_chain = self.blockchain.tree.longest_chain()
        public_chain_blkid = []
        for i in public_chain:
            public_chain_blkid.append(i.header['blkid'])
        d_prev = len(self.chain) - len(public_chain)
        status, code = self.blockchain.add_block_to_chain(block, timestamp)
        if g.mining_log:
            print(timestamp, "selfish added honest block", block, status, code)
        print(timestamp,"Lead is", d_prev)
        for c in public_chain:
            if c.header['block_hash'] == block.header['prev_hash']:
                '''if d_prev == 1:
                     Assignment Part A Section 1 
                    Lead is 1 and honest miners find one block. publish the private block
                    
                    for i in self.chain[-1:]:
                        if i.header['blkid'] not in public_chain_blkid:
                            status, code = self.blockchain.add_block_to_chain(i, timestamp)
                            print(timestamp, d_prev, "99 added private block to public", i, status, code)
                            timestamp += lag
                            message = Message('blk', i)
                            self.broadcast_message(timestamp, message, self)

                    event = Event(timestamp, [self.check_mempool, timestamp])
                    des.heapq.heappush(des.q, event)'''


                if d_prev >= 0:
                    ''' Assignment Part A Section 3
                    Lead is gtreater than 2 and honest miners find one block. publish  releasing a subchain 
                    that ends with that block which enters into competition with the new honest block.
                    '''
                    for i in self.chain:
                        if i.header['blkid'] not in public_chain_blkid:
                            status, code = self.blockchain.add_block_to_chain(i, timestamp)
                            print(timestamp, d_prev, "99 added private block", block, status, code)
                            timestamp += lag
                            message = Message('blk', i)
                            event = Event(timestamp, [self.broadcast_message, timestamp, message, self])
                            des.heapq.heappush(des.q, event)
                            if i.header['prev_hash'] == block.header['prev_hash']:
                                break

                    event = Event(timestamp, [self.check_mempool, timestamp])
                    des.heapq.heappush(des.q, event)
                if d_prev<0:
                    ''' WHen lead is 0 and honest miners find one block reinitialize private chain'''
                    self.on_init(timestamp)
                    event = Event(timestamp, [self.check_mempool, timestamp])
                    des.heapq.heappush(des.q, event)
                break

    def end_broadcast(self, timestamp):
        public_chain = self.blockchain.tree.longest_chain()
        for i in self.chain:
            if i not in public_chain:
                for n in g.node_list:
                    n.blockchain.add_block_to_chain(i, timestamp)

    def add_block(self, timestamp, blkid):
        ''' Add a block after mining'''
        block = self.pending_block
        if block is not None:
            print(timestamp, "selfish mined a block", block)
            self.chain.append(block)
            self.check_completed_trans(self.chain)
            self.block_qty += 1
        self.pending_block = None
        self.busy = False
        event = Event(timestamp + lag, [self.check_mempool, timestamp + lag])
        des.heapq.heappush(des.q, event)

    def check_completed_trans(self, chain=None):
        ''' Remove Trans after adding block to chain'''
        if chain is None:
            chain = self.blockchain.tree.longest_chain()
        valid_trans_list = self.blockchain.get_chain_trans_list(chain)
        li = list(self.mempool)
        c_li = list(self.completed)
        temp = set()
        for i in c_li:
            if i not in valid_trans_list:
                temp.add(i)
                self.completed.discard(i)
        for i in li:
            if i in valid_trans_list:
                self.mempool.discard(i)
                self.completed.add(i)
        for i in temp:
            self.mempool.add(i)
    def create_block(self, timestamp, chain=None):
        """Selection of transaction and Mining of block happens here"""
        if chain is None:
            chain = self.blockchain.tree.longest_chain()
        new_blkid = g.blkid_gen()
        mem_pool_list = list(self.mempool)
        conf_trans_list = self.blockchain.get_chain_trans_list(chain)
        last_block = chain[-1]
        txn_list = [i for i in mem_pool_list if i not in conf_trans_list]
        txn_list = [i for i in txn_list if self.verify_txn(conf_trans_list, i)]
        prev_hash = last_block.header['block_hash']
        new_timestamp = random.exponential(scale=self.hash_mean, size=1)[0] + timestamp
        if txn_list:
            if g.mining_log_detail:
                print(timestamp, "\tmining of ", new_blkid, " started by\t", self.id, "\t")

            status, new_block = self.blockchain.create_block(blkid=new_blkid, list_trans=txn_list[0:100], \
                                                             timestamp=new_timestamp, version=g.VERSION,
                                                             creator=self.id, prev_hash=prev_hash)
            if status:
                self.busy = True
                self.pending_block = new_block
                event = Event(new_timestamp, [self.add_block, new_timestamp, new_block.header['blkid']])
                des.heapq.heappush(des.q, event)
